<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Claudio Mandelli</title><link>https://cmanziel.github.io/</link><description>Recent content on Claudio Mandelli</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://cmanziel.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Minecraft-like terrain</title><link>https://cmanziel.github.io/p/minecraft-like-terrain/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cmanziel.github.io/p/minecraft-like-terrain/</guid><description>&lt;img src="https://cmanziel.github.io/p/minecraft-like-terrain/terrain_noise.png" alt="Featured image of post Minecraft-like terrain" />&lt;p>This project aims to recreate a Minecraft-like terrain generation without using an engine. Made using OpenGL and the GLFW, GLM and GLEW libraries. &lt;a class="link" href="https://github.com/cmanziel/mncrft" target="_blank" rel="noopener"
>Source code&lt;/a>.&lt;/p>
&lt;h2 id="main-classes">Main Classes
&lt;/h2>&lt;p>These are the main classes used in the project:&lt;/p>
&lt;h3 id="terrain">Terrain
&lt;/h3>&lt;p>The terrain is composed of chunks, which are generated around the player according to his position in space.&lt;/p>
&lt;h3 id="chunk">Chunk
&lt;/h3>&lt;p>A single chunk is a collection of Blocks, every chunk allocates in the memory its own blocks, giving them a local position and a world position based on its own. From every chunk is created a Mesh, which is the actual collection of vertices that will be sent to the shaders to be drawn on the screen.&lt;/p>
&lt;h3 id="block">Block
&lt;/h3>&lt;p>A Block is the smallest component of the terrain. Each block has a different ID according to its local y coordinate in the chunk. The ID determines which texture will be applied to the block&amp;rsquo;s faces and if the block is to be considered solid or not when the mesh of its chunk is being created. Block IDs are &lt;em>air&lt;/em>, &lt;em>dirt&lt;/em>, &lt;em>grass&lt;/em>, &lt;em>cobblestone&lt;/em>.&lt;/p>
&lt;h3 id="mesh">Mesh
&lt;/h3>&lt;p>The mesh is the collection of vertices of a chunk that will eventually be drawn to the screen. It is created by evaluating if the blocks&amp;rsquo; faces would be visible by the player, if not there&amp;rsquo;s no need to draw them on the screen. The mesh vertices will then be used as the buffer in the function glBufferData or glBufferSubData.&lt;/p>
&lt;h3 id="shader-and-buffer">Shader and Buffer
&lt;/h3>&lt;p>These are the classes that wrap around the opengl functions. They are responsible of creating a shader program, compiling it and deleting it, allocating the gl buffers and update them with data from the meshes.&lt;/p>
&lt;h2 id="terrain-generation">Terrain generation
&lt;/h2>&lt;ul>
&lt;li>In the Terrain class constructor every Chunk class instance is allocated and stored row-by-row along the z axis in a bidimensional array.&lt;/li>
&lt;li>The chunks grid consists of a number of CHUNK_RADIUS chunks created along the positive and negative z and x axis from the player&lt;/li>
&lt;li>Then for every chunk the function GenerateMeshes is called: the function checks if the current chunk being processed is in front of the camera to determine if the mesh should be generated or not&lt;/li>
&lt;li>After the call of GenerateMeshes the value of m_CurrentChunk is incremented to process, in the next frame, the next chunk in the grid&lt;/li>
&lt;li>When the player crosses the edge of the chunk it&amp;rsquo;s in, the terrain around it is regenerated: chunks that are distant more then CHUNK_RADIUS from its position in the grid are deleted and new ones are generated in the direction it&amp;rsquo;s moving&lt;/li>
&lt;li>When this occurs, m_CurrentChunk is reset to 0 because all the meshes should be generated again according to the new chunks&amp;rsquo; disposition that affects some of the chunks&amp;rsquo; surroundings&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://cmanziel.github.io/p/minecraft-like-terrain/terrain_noise.png"
width="1264"
height="940"
srcset="https://cmanziel.github.io/p/minecraft-like-terrain/terrain_noise_hu8683083574416825653.png 480w, https://cmanziel.github.io/p/minecraft-like-terrain/terrain_noise_hu16460420673969726289.png 1024w"
loading="lazy"
alt="Terrain generated with the use of Perlin noise to determine the height of every column of blocks."
class="gallery-image"
data-flex-grow="134"
data-flex-basis="322px"
>&lt;/p>
&lt;h2 id="mesh-generation">Mesh generation
&lt;/h2>&lt;ul>
&lt;li>every chunk has a m_LowestSolidHeight field that holds the lowest y coordinate value of the block whose ID is not &lt;em>air&lt;/em>. The m_Blocks array is iterated through starting from the lowest solid block&amp;rsquo;s index&lt;/li>
&lt;li>the condition checked first is if the block&amp;rsquo;s world position lies inside the camera&amp;rsquo;s frustum.&lt;/li>
&lt;li>for every face of the blocks is checked if there is a neighbouring block which is solid. If it is not, then the vertices of the face should be added to the mesh because they will be visible&lt;/li>
&lt;li>if a face is at the edge of a chunk, then the program checks if the neighbouring chunk exists and if it has a solid block adjacent to the face&lt;/li>
&lt;li>By doing this only the vertices that make up the external profile of the chunk will be rendered&lt;/li>
&lt;li>three vectors store the data that&amp;rsquo;s needed to correctly render a block face: m_Faces,m_TexCoords and m_ModelMats&lt;/li>
&lt;/ul>
&lt;p>&lt;em>m_Faces&lt;/em>: each face of a block has its array of data in the header file Renderer.h. For every face added to the mesh one of the values of the enum variable &amp;ldquo;sides&amp;rdquo; is pushed back to the m_Faces vector. So when the process of mesh generation is done m_Faces is a collection of indexes that determine which of the six arrays that represent a face will be used in the shader.&lt;/p>
&lt;p>&lt;em>m_TexCoords&lt;/em>: for every vertex added to the mesh the corresponding 2D textures coordinates are pushed back to the m_TexCoords vector.
The texture coordinates referer to the texture atlas image and depend on the block&amp;rsquo;s ID&lt;/p>
&lt;p>&lt;em>m_ModelMats&lt;/em>: for every face added to the mesh, a mat4 4x4 matrix is pushed back to the m_ModelMats vector. These are the matrices that will compute the correct 3D position of a vertex.
When a face is deemed to be part of the chunk&amp;rsquo;s mesh a model matrix is calculated from its block&amp;rsquo;s world position and in the vertex shader every position of the vertices of that face will be trasnformed by the matrix&lt;/p>
&lt;p>&lt;img src="https://cmanziel.github.io/p/minecraft-like-terrain/no_shell.png"
width="2160"
height="1317"
srcset="https://cmanziel.github.io/p/minecraft-like-terrain/no_shell_hu797035067625271222.png 480w, https://cmanziel.github.io/p/minecraft-like-terrain/no_shell_hu13492098786487757639.png 1024w"
loading="lazy"
alt="A chunk of blocks before evaluating its mesh."
class="gallery-image"
data-flex-grow="164"
data-flex-basis="393px"
>&lt;/p>
&lt;p>&lt;img src="https://cmanziel.github.io/p/minecraft-like-terrain/shell.png"
width="2160"
height="1318"
srcset="https://cmanziel.github.io/p/minecraft-like-terrain/shell_hu6658714075232909009.png 480w, https://cmanziel.github.io/p/minecraft-like-terrain/shell_hu7867860755738880723.png 1024w"
loading="lazy"
alt="A chunk of blocks after evaluating its mesh, every vertex inside the chunk is not rendered."
class="gallery-image"
data-flex-grow="163"
data-flex-basis="393px"
>&lt;/p>
&lt;h2 id="textures">Textures
&lt;/h2>&lt;p>To every visible face of a block is applied a texture according to its ID. All the different textures are stored in a single texture atlas, handled by the &lt;em>TextureAtlas&lt;/em> class, and are retrieved through the correct offset based on the block&amp;rsquo;s ID.&lt;/p>
&lt;p>&lt;img src="https://cmanziel.github.io/p/minecraft-like-terrain/textures.png"
width="1444"
height="992"
srcset="https://cmanziel.github.io/p/minecraft-like-terrain/textures_hu14781416119664205185.png 480w, https://cmanziel.github.io/p/minecraft-like-terrain/textures_hu1641730381601720174.png 1024w"
loading="lazy"
alt="Textures applied to the blocks&amp;rsquo; faces."
class="gallery-image"
data-flex-grow="145"
data-flex-basis="349px"
>&lt;/p>
&lt;p>&lt;img src="https://cmanziel.github.io/p/minecraft-like-terrain/texture_ids.png"
width="1267"
height="948"
srcset="https://cmanziel.github.io/p/minecraft-like-terrain/texture_ids_hu6595682822299860728.png 480w, https://cmanziel.github.io/p/minecraft-like-terrain/texture_ids_hu12111103027935513723.png 1024w"
loading="lazy"
alt="Different textures for different block IDs based on the height they&amp;rsquo;re at."
class="gallery-image"
data-flex-grow="133"
data-flex-basis="320px"
>&lt;/p>
&lt;h2 id="block-breaking">Block Breaking
&lt;/h2>&lt;p>A ray is sent from the player&amp;rsquo;s camera into the world. If it intersects a block whose ID isn&amp;rsquo;t &lt;em>air&lt;/em> the block&amp;rsquo;s edges are highlighted. On mouse input, the block&amp;rsquo;s ID is set to &lt;em>air&lt;/em> so that when the mesh is regenerated its faces won&amp;rsquo;t be rendered, conveying the effect of breaking the block.
The highlighting of the edges is done by giving every vertex of a face &lt;em>barycentric coordinates&lt;/em> and then checking them in the fragment shader to determine if the vertex is at the edge of a face.&lt;/p>
&lt;p>&lt;img src="https://cmanziel.github.io/p/minecraft-like-terrain/block_pointed.png"
width="1258"
height="942"
srcset="https://cmanziel.github.io/p/minecraft-like-terrain/block_pointed_hu5718781423390599879.png 480w, https://cmanziel.github.io/p/minecraft-like-terrain/block_pointed_hu14900624964200655163.png 1024w"
loading="lazy"
alt="Highlighting the block pointed by the player."
class="gallery-image"
data-flex-grow="133"
data-flex-basis="320px"
>&lt;/p></description></item><item><title>ImageEditor</title><link>https://cmanziel.github.io/p/imageeditor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cmanziel.github.io/p/imageeditor/</guid><description>&lt;img src="https://cmanziel.github.io/p/imageeditor/collage.png" alt="Featured image of post ImageEditor" />&lt;p>This project combines two other ones i made before.
One is about drawing on a window using the mouse cursor as a brush, the other is the pnglib library to convert into an image what&amp;rsquo;s been drawn on the window. &lt;a class="link" href="https://github.com/cmanziel/ImageEditor" target="_blank" rel="noopener"
>Source code&lt;/a>.&lt;/p>
&lt;h2 id="window">Window
&lt;/h2>&lt;p>The window is conceptually divided into a grid of pixels, whose data is stored in a bi-dimensional array of &lt;em>point&lt;/em> structures.
The image pixels are mapped 1:1 to the window pixels.
The window creation is done through GLFW.&lt;/p>
&lt;h2 id="image-decompression">Image Decompression
&lt;/h2>&lt;p>To edit the image it has to be firstly displayed onto the window.
To do so the image has to be decompressed to get the raw pixel data containing the rgb values for each pixel.
The decompression is handled by the &lt;em>pnglib&lt;/em> library: its &lt;em>decompress&lt;/em> function receives the image file and returns its pixel data.
If no image is provided or the file is corrupted a default white color is applied to every pixel&lt;/p>
&lt;h2 id="brush">Brush
&lt;/h2>&lt;p>A brush is constructed around the mouse cursor as a circular grid.
The center of the grid is the pixel the cursor is currently pointing.
Its dimensions can vary on mouse input or based on the cursor&amp;rsquo;s speed as selected by the user.
Handled by the Brush class.&lt;/p>
&lt;p>&lt;img src="https://cmanziel.github.io/p/imageeditor/drawing_site.jpg"
width="400"
height="200"
srcset="https://cmanziel.github.io/p/imageeditor/drawing_site_hu10146579996135543304.jpg 480w, https://cmanziel.github.io/p/imageeditor/drawing_site_hu3170732616649402332.jpg 1024w"
loading="lazy"
alt="Drawing before the brush implementation: the cursor colors only the pixel at its position."
class="gallery-image"
data-flex-grow="200"
data-flex-basis="480px"
>&lt;/p>
&lt;p>&lt;img src="https://cmanziel.github.io/p/imageeditor/drawing_0_site.jpg"
width="2000"
height="1000"
srcset="https://cmanziel.github.io/p/imageeditor/drawing_0_site_hu115328198846691255.jpg 480w, https://cmanziel.github.io/p/imageeditor/drawing_0_site_hu17636706954641804793.jpg 1024w"
loading="lazy"
alt="Brush implemented as a square grid. Its dimension is modified through key input."
class="gallery-image"
data-flex-grow="200"
data-flex-basis="480px"
>&lt;/p>
&lt;h2 id="pointbuffer">PointBuffer
&lt;/h2>&lt;p>This is the class that actually handles the window&amp;rsquo;s grid allocation in memory and modifies its values.
The functions &lt;em>InsertPoint&lt;/em> and &lt;em>RemovePoint&lt;/em> use the brush&amp;rsquo;s position and dimension to draw the correct points on the image.&lt;/p>
&lt;h2 id="image-generation">Image Generation
&lt;/h2>&lt;p>The initial image&amp;rsquo;s pixel data is overwritten by what&amp;rsquo;s drawn onto it.
The window&amp;rsquo;s bi-dimensional grid array serves as the raw pixel data input for the &lt;em>compress&lt;/em> function of the &lt;em>pnglib&lt;/em> library.
A PNG file is written from scratch by the library inserting the compressed pixel data into it.&lt;/p>
&lt;p>&lt;img src="https://cmanziel.github.io/p/imageeditor/collage.png"
width="1920"
height="1920"
srcset="https://cmanziel.github.io/p/imageeditor/collage_hu1759512000934668714.png 480w, https://cmanziel.github.io/p/imageeditor/collage_hu3895675240254944732.png 1024w"
loading="lazy"
alt="Drawing on images previously generated by this application. Brush implemented as a circular grid."
class="gallery-image"
data-flex-grow="100"
data-flex-basis="240px"
>&lt;/p>
&lt;!-- ## Syntax
```markdown
![Image 1](1.jpg) ![Image 2](2.jpg)
```
## Result
![Image 1](1.jpg) ![Image 2](2.jpg)
> Photo by [mymind](https://unsplash.com/@mymind) and [Luke Chesser](https://unsplash.com/@lukechesser) on [Unsplash](https://unsplash.com/) --></description></item><item><title>CSImage</title><link>https://cmanziel.github.io/p/csimage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cmanziel.github.io/p/csimage/</guid><description>&lt;img src="https://cmanziel.github.io/p/csimage/effects.png" alt="Featured image of post CSImage" />&lt;p>This project is a refactor of the &lt;a class="link" href="https://github.com/cmanziel/ImageEditor" target="_blank" rel="noopener"
>ImageEditor&lt;/a> project. The first version of the project was mainly relying on the CPU for all the drawing and effects processes. This one uses compute shaders for every step of the way. &lt;a class="link" href="https://github.com/cmanziel/CSImage" target="_blank" rel="noopener"
>Source code&lt;/a>.&lt;/p>
&lt;h2 id="drawing">Drawing
&lt;/h2>&lt;p>Each drawing style the brush can have has its own shader. The shader samples the canvas texture to retrieve the background color through GLSL&amp;rsquo;s &lt;em>imageLoad&lt;/em> function, and stores the color being drawn into the render target texture.
After the off-screen rendering is done, the render texture is mapped to the vertices of a quad which is rendered through the usual vertex and fragment shader.&lt;/p>
&lt;p>For every compute shader, a &lt;em>brush radius&lt;/em> * &lt;em>brush radius&lt;/em> number of work groups is dispatched. The &lt;em>local_size&lt;/em> of every work group is 1 x 1 x 1, so the image can be accessed using the &lt;em>gl_GlobalInvocationID.xy&lt;/em> built-in variable as the UV coordinates.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">Execute&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Dispatch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">m_BrushRadius&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">m_BrushRadius&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">Dispatch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">xGroups&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">yGroups&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">zGroups&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">glDispatchCompute&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">xGroups&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">yGroups&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">zGroups&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">glMemoryBarrier&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">GL_SHADER_IMAGE_ACCESS_BARRIER_BIT&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">GL_SHADER_STORAGE_BARRIER_BIT&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="brush-effects">Brush Effects
&lt;/h2>&lt;h3 id="edge-detection-sobel-operator">Edge Detection (Sobel Operator)
&lt;/h3>&lt;p>&lt;a class="link" href="https://en.wikipedia.org/wiki/Sobel_operator" target="_blank" rel="noopener"
>Two kernels&lt;/a> are defined to process every pixel in area covered by the brush based on its surrounding pixels.
The effect is applied on everything that has been drawn onto the canvas and not only on the original canvas.&lt;/p>
&lt;p>To prevent &lt;em>imageStore&lt;/em> operations to affect &lt;em>imageLoad&lt;/em> operations in the same shader dispatch a separate canvas texture image is used.
This prevents an &lt;em>imageLoad&lt;/em> operation to get the value of another pixel in the grid which was just modified by the same operation that is being done on the current one.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">float&lt;/span> &lt;span class="nf">kernel_mult&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ivec2&lt;/span> &lt;span class="n">pixel_uv&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">ch&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">mat3&lt;/span> &lt;span class="n">kernel&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">kernel_sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ivec2&lt;/span> &lt;span class="n">dims&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">imageSize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">edited&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ivec2&lt;/span> &lt;span class="n">grid_uv&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">pixel_uv&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nf">ivec2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">vec4&lt;/span> &lt;span class="n">current_color&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">imageLoad&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sobelCanvas&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nf">ivec2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">grid_uv&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">grid_uv&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">kernel_sum&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">current_color&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">ch&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">kernel&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">kernel_sum&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">vec4&lt;/span> &lt;span class="nf">edge_pixel&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ivec2&lt;/span> &lt;span class="n">uv&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// imageLoad with an out of boundary coordinate returns an all zeroes vec4
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// so for the edge pixels of the imagedo the kernel multiplication with out of bounds values as for the other pixels
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">vec4&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// for each of the rgb channels compute the kernel calculation
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">Gx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">kernel_mult&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uv&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sobel_kernel_Gx&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">Gy&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">kernel_mult&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uv&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sobel_kernel_Gy&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// sqrt is a floating point operation
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">sqrt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Gx&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">Gx&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">Gy&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">Gy&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">SOBEL_CLAMP_FLOAT_VALUE&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sum&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">xyz&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">vec3&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sum&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="blur-box-blur">Blur (Box Blur)
&lt;/h3>&lt;p>A &lt;a class="link" href="https://en.wikipedia.org/wiki/Box_blur" target="_blank" rel="noopener"
>Box Blur&lt;/a> algorithm is applied to every pixel inside the brush area. The result is the average value between a 3x3 grid around each pixel. The effect is applied on everything that has been drawn onto the canvas and not only on the original canvas.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="n">vec4&lt;/span> &lt;span class="nf">blur_pixel&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ivec2&lt;/span> &lt;span class="n">uv&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">ivec2&lt;/span> &lt;span class="n">dims&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">vec4&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// if the pixel is on the edge of the image, return it unmodified
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uv&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">uv&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">y&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">uv&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">dims&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">uv&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">y&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">dims&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nf">imageLoad&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">blurCanvas&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uv&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">continue&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ivec2&lt;/span> &lt;span class="n">grid_uv&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">uv&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nf">ivec2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">vec4&lt;/span> &lt;span class="n">current_color&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">imageLoad&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">blurCanvas&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nf">ivec2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">grid_uv&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">grid_uv&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">current_color&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">xyz&lt;/span> &lt;span class="o">/=&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;!-- ## Syntax
```markdown
![Image 1](1.jpg) ![Image 2](2.jpg)
```
## Result
![Image 1](1.jpg) ![Image 2](2.jpg)
> Photo by [mymind](https://unsplash.com/@mymind) and [Luke Chesser](https://unsplash.com/@lukechesser) on [Unsplash](https://unsplash.com/) --></description></item><item><title>pnglib</title><link>https://cmanziel.github.io/p/pnglib/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cmanziel.github.io/p/pnglib/</guid><description>&lt;img src="https://cmanziel.github.io/p/pnglib/cover.jpg" alt="Featured image of post pnglib" />&lt;p>Static library to encode or decode PNG files by compressing data into zlib datastreams or decompressing from them.
The aim of this project was to generate an uncorrupted PNG file from scratch. &lt;a class="link" href="https://github.com/cmanziel/pnglib" target="_blank" rel="noopener"
>Source code&lt;/a>.&lt;/p>
&lt;h2 id="png-file-structure">PNG file structure
&lt;/h2>&lt;p>According to the &lt;a class="link" href="https://www.w3.org/TR/png-3" target="_blank" rel="noopener"
>PNG specification&lt;/a> a PNG file has to contain at least each one of these chunks of data:&lt;/p>
&lt;h3 id="ihdr">IHDR
&lt;/h3>&lt;p>This is the image header chunk. It contains general information about the image like width, height, pixel data length and format and an 8-byte signature that every PNG file contains.&lt;/p>
&lt;h3 id="idat">IDAT
&lt;/h3>&lt;p>This is the chunk that contains the actual image pixel data. The original raw data, stored in the format indicated in the IHDR chunk, has to be compressed through the zlib library&amp;rsquo;s DEFLATE routine and put into one or multiple IDAT chunks one after each other. An incorrect zlib&amp;rsquo;s datastream will result in a corrupted PNG file.&lt;/p>
&lt;h3 id="iend">IEND
&lt;/h3>&lt;p>Chunk at the end of the image file.&lt;/p>
&lt;h2 id="image-encoding">Image Encoding
&lt;/h2>&lt;p>Each chunk consists of three or four fields:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Length&lt;/strong>: A four-byte unsigned integer giving the number of bytes in the chunk&amp;rsquo;s &lt;em>data&lt;/em> field.&lt;/li>
&lt;li>&lt;strong>Chunk type&lt;/strong>: The data bytes appropriate to the chunk type, if any. This field can be of zero length.&lt;/li>
&lt;li>&lt;strong>Chunk data&lt;/strong>: the actual data for the chunk in use&lt;/li>
&lt;li>&lt;strong>CRC&lt;/strong>: A four-byte CRC calculated on the preceding bytes in the chunk, including the chunk type field and chunk data fields, but not including the length field.&lt;/li>
&lt;/ul>
&lt;p>When encoding a PNG file the library function &lt;em>compress&lt;/em> calls the zlib&amp;rsquo;s compression routines, sets the necessary fields for every chunk (like signatures and CRCs) and writes to the image file opened.&lt;/p>
&lt;h2 id="image-decoding">Image Decoding
&lt;/h2>&lt;p>When decoding a PNG file the library searches all the IDAT chunks in the file, concatenates their data to get the whole zlib datastream, decompresses it to the original pixel data and returns it.&lt;/p></description></item><item><title>About Me</title><link>https://cmanziel.github.io/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cmanziel.github.io/about/</guid><description>&lt;p>I started learning programming while still a student and my interest naturally drifted to it. My focus has shifted from university to it from time to time in the past couple of years until i decided to give it a shot and try to be a programmer by trade.&lt;/p>
&lt;p>I&amp;rsquo;m curious about the low level aspects of how things work, that&amp;rsquo;s why i focused on OpenGL, C and C++ so far and tried to create as much as possible from scratch.
I consider myself a person capable of adapting to various contexts since i&amp;rsquo;ve done different types of jobs in the past, and very eager to learn, i always try to make time in the day to expand my knowlege about a topic.&lt;/p>
&lt;p>I like enjoying my free time practicing and watching sports or going on an hike. My main choices when it comes to entertainment are podcasts and stand-up comedy.&lt;/p></description></item><item><title>Search</title><link>https://cmanziel.github.io/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cmanziel.github.io/search/</guid><description/></item></channel></rss>